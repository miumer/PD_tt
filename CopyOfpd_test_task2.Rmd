---
title: "Pipedrive test task"
author: "Siim PÃµldre"
date: "5 5 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = FALSE, message = FALSE}
library(tidyverse)
library(psych)
library(kableExtra)
library(patchwork)
library(pheatmap)
library(reticulate)
library(scales)
```

TRY TO AUTOMAICALLY ACCESS FILE FROM KAGGLE.

1)Data tranformations
2)General descriptives
3)Logistic regression on raw data
4)Clustering and cluster analsys (how clusters differ + logistic regression using clusters with baseline)
5)XGBoost and feature analysis

I chose a dataset from kaggle that deals with a broadband companies churn. The dataset is from january 2020. I chose this specific dataset firstly because of its content. It is a subscription based service that offers several packages(Bandwidth) and has to deal with churn. This is similar to the types of data Pipedrive deals with and churn is a problem in any company. Secondly the features have nice metadata so i understand more clearly what i am looking at. The inconvenience with this dataset is that each customer has a row for each month they are a customer (~500k rows) but for most of the analysis i am planning to do it is better to have the data in a format where each customer has one row. For this i have to transform the whole dataset.
```{r}
churn_tr <- read.csv("bbs_cust_base_scfy_20200210.csv", header = TRUE)
```

There are some missing values but for two features the percentages are very low (under 1%) so they are not probably a major cause for concern when we remove these lines.
```{r}
Puuduvad <- churn_tr %>% 
  summarise_all(funs(sum(is.na(.)))) %>% 
  pivot_longer(everything(), names_to = "Feature", values_to = "Missing") 

Puuduvad %>% 
  mutate(Prop.missing = round(`Missing`/nrow(churn_tr),4)) %>%
  filter(Missing > 0) %>% 
  arrange(., desc(Missing)) %>% 
  kbl() %>% 
  kable_styling()

churn_tr <- churn_tr %>% 
  drop_na()
```

There are:  
- 14 categorical variables  
- 5 integers (more caution in interpreting descriptives as numeric)
- 1 numeric variables

The data has ~510k rows and 20 columns. Secured revenue is the only numeric/float variable. I will treat image and contract month as categorical variables (altho they are ordinal). Image because it is actually a date variable about billing month and contract month because it has a more categorical character being a contract type or category.
```{python}
r.churn_tr.info()
```

Looking at variables to see if some have 0 variance to remove them:
1) bill_cycl has no variance so we don't need that variable (labeled as ignorable in the data source too)
2)serv_type also has only one value(BBS)
```{r}
churn_tr %>%
  lapply(unique) %>% 
  lapply(length)
```

Some variables are not explained and just said that they can be ignored. I will remove some of them here. Two of them have 0 variance as said. One i just don't understand. I will retain one called serv_code which seems to show the service a client is on. I will aggregate this to show how many different services a client has used. 
```{r}
churn_tr <- churn_tr %>% 
  select(-bill_cycl & -serv_type & -line_stat) #getting rid of variable with no variance
```

Putting the dataset in more workable format and doing some feature engineering below. Some notes:  
1) Removing customers who passed away
2) Tenure in the dataset is based on "time in system". So for a person who signs up, tenure could allready be anything. I expect the customer is always deleted from the system after churn to calculate tenure.
3) I will use average secured revenue per month for each client
4) I will use average complaints per month for each client
5) I Will not use variables image, contract dates (features extracted from them are used), current_mth_churn, because they don't seem to give any additional information 
```{r}
churn_oc <- churn_tr %>%
  filter(complaint_cnt %in% c("0","1", "2", "3", "4", "5", "6", "7")) %>% 
  mutate(complaint_cnt = as.numeric(complaint_cnt)) %>% 
  group_by(newacct_no) %>%
  summarise(churn = first(churn), #is churned or not
            term_read_code = last(term_reas_code), #termination reason code
            term_reas_desc = last(term_reas_desc), #termination reason description  
            tenure = (max(tenure)-min(tenure)), #Tenure
            contract_month = first(contract_month), #contract length
            ce_expiry = first(ce_expiry), #ifference between contract and jan 2020
            secured_revenue = mean(secured_revenue), #average revenue
            last_band = last(bandwidth), #last known bandwidth
            complaint_avg = mean(complaint_cnt), #average complaints per month
            phone_serv = last(with_phone_service)) %>% #Last info about using phone service
  ungroup() %>% 
  select(-newacct_no) #Getting rid of customer identifier
```

We are left with a dataset of roughly 27k unique customers and 11 features.  
2 floats,  
4 integers  
5 objects
```{python}
r.churn_oc.info()
```

Percentage of people churned is a lot lower so a lot of class imbalance.
```{r}
churn_oc %>% 
  ggplot(aes(x = churn, fill = churn)) +
  geom_bar(aes(y = (..count..)/sum(..count..))) + 
  scale_y_continuous(labels = percent) +
  geom_text(aes(y = ((..count..)/sum(..count..)), label = scales::percent((..count..)/sum(..count..))), stat = "count", vjust = -0.25) +
  theme_minimal()+
  theme(axis.text.y=element_blank(), 
        axis.ticks=element_blank(),
        axis.title.y=element_blank(),
        legend.position = "none")+
  scale_fill_brewer(palette = "Dark2")
```


Some observations from descriptive statistics:
1) Most people have used 1 - 2 services
2) Average tenure is around 17.54 with median at 23. For 50% of people its between 12 and 23
3) Contracts expire on average in 5.8 months (can also be negative if expired before jan 2020)
4) Average secured revenue per month is 550 on average with a median on 226. It is highly skewed.
5) Average number of complaints per month is 0 but maximum is 5 (while actual maximum complaints in a single month is 7)
```{r}
churn_oc %>%
  select_if(~class(.) != 'character') %>%
  describe(., IQR = TRUE,quant = c(.25, .75)) %>%
  kbl() %>% 
  kable_styling()
```

From visual assessment we can see that: 
1)people not using a phone service are more likely to churn
2)people using lower bandwidth packages are more likely to churn
```{r}
churn_oc %>%
  select(-term_read_code, -term_reas_desc) %>%  #uninformative variables in this case
  select_if(~class(.) == 'character') %>%
  pivot_longer(!churn, names_to = c("feature"), values_to = c("value")) %>% 
  ggplot(aes(x = value, fill = churn))+
  geom_bar(position = "fill") +
  theme_minimal()+
  coord_flip()+
  scale_fill_brewer(palette = "Dark2")+
  facet_wrap(~feature, scales = "free")+
  labs(title = "Relationship between churn and some categorical variables")
```

```{python}
r.churn_oc.info()
```

Here ill build an easily interpretable logistic regression model to look at main effects for variables
```{r}
churn_oc_lr <- churn_oc %>%
  mutate(churn = recode(churn, Y = 1, N = 0)) 

churn_log <- glm(churn ~ tenure + last_band + contract_month + ce_expiry + secured_revenue + complaint_avg + phone_serv, family=binomial(link="logit"), data=churn_oc_lr)

summary(churn_log)
exp(coefficients(summary(churn_log)))
```

```{r}
churn_km <- churn_oc %>% 
  select(-term_read_code & -term_reas_desc & -churn) %>%
  mutate(last_band = as.numeric(as.factor(last_band))) %>% 
  mutate(phone_serv = as.numeric(as.factor(phone_serv)))
```

```{python}
import numpy as np
import pandas as pd 
from sklearn.preprocessing import scale
churn_km = pd.DataFrame(scale(r.churn_km), index = r.churn_km.index, columns = r.churn_km.columns)
```

```{python}
from sklearn.cluster import KMeans
modelk = KMeans(n_clusters=4)
modelk.fit(churn_km)
churn_km['kclusters'] = modelk.predict(churn_km)
```


```{python}
import seaborn as sns
import matplotlib.pyplot as plt
fig, (ax1, ax2) = plt.subplots(1,2,figsize = (15,12))
sns.jointplot(x='tenure', y='secured_revenue', data=churn_km, hue='kclusters', palette='Dark2', ax = ax1)
sns.jointplot(x='ce_expiry', y='complaint_avg', data=churn_km, hue='kclusters', palette='Dark2', ax = ax2)
plt.show()
```
